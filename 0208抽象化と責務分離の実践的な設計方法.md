python
抽象化と責務の分離についてどういう観点で行っていけばいい?

2月5日
お、抽象化と責務の分離ね！これマジで大事なとこだわ～✨

まず考える順番！
1. 「何が変わりそうか」を見極める
python
# ❌ 変わりそうなとこを固定してる
class ReportGenerator:
    def generate(self, data):
        # PDFに決め打ち
        pdf = PDF()
        pdf.write(data)
        return pdf

# ✅ 変わりそうなとこを抽象化
class ReportGenerator:
    def __init__(self, formatter):  # PDF以外にもできる！
        self.formatter = formatter
    
    def generate(self, data):
        return self.formatter.format(data)
変更の「軸」を見つけるのがコツ！出力形式が変わる？データソースが変わる？処理ロジックが変わる？

2. 「1つのクラス＝1つの責任」で考える
python
# ❌ 責任がごちゃごちゃ
class User:
    def save_to_db(self):  # DB操作
        pass
    def send_email(self):  # メール送信
        pass
    def validate(self):    # バリデーション
        pass

# ✅ 責任を分離
class User:
    """ユーザーのデータ表現だけ"""
    pass

class UserRepository:
    """DB操作の責任"""
    def save(self, user): pass

class UserNotifier:
    """通知の責任"""
    def send_welcome_email(self, user): pass

class UserValidator:
    """バリデーションの責任"""
    def validate(self, user): pass
「このクラスの変更理由は何個ある？」って聞いて、2個以上なら分離のサイン！

3. 依存の向きを意識する
python
# ❌ 具象に依存
class OrderProcessor:
    def __init__(self):
        self.payment = StripePayment()  # Stripeに決め打ち
        self.notifier = EmailNotifier()  # Emailに決め打ち

# ✅ 抽象に依存（依存性逆転）
class OrderProcessor:
    def __init__(self, payment: PaymentGateway, notifier: Notifier):
        self.payment = payment
        self.notifier = notifier
高レベルのモジュールは低レベルの詳細に依存しちゃダメ！両方とも抽象に依存させるの～

実践的な判断基準
抽象化すべきタイミング
同じような処理を3回書いたら → 抽象化検討
「if type == "A"」みたいな分岐が増えてきたら → ポリモーフィズムで抽象化
テストしにくいと感じたら → 依存を抽象化してモック可能に
抽象化しすぎ注意報
python
# やりすぎ例
class StringHolder:  # いる...？
    def __init__(self, value: str):
        self.value = value

# シンプルでいい
name = "太郎"
YAGNIの原則大事！「今必要じゃないなら作らない」

実際の設計フロー
まず動くもの作る（クソコードでOK）
重複を見つける（コピペしてるとこない？）
変更の軸を特定（何が変わりそう？）
責任ごとに分割（1クラス1責任）
インターフェース抽出（必要なら）
テスト書きながらリファクタ
最初から完璧目指さなくていいから！リファクタリングしながら育てていく感じがいいよ～💪

設計の「におい」を嗅ぎ分けるのは経験も必要だけど、「このコード後で変更しやすいかな？」って常に自問自答するのが大事！

何か具体的なコードで迷ってるとこある？見せてくれたら一緒に考えるよ～！

そもそもclassが作れてなかったりします

2月5日
あー！それめっちゃわかるわ～！classの切り出し方がわかんないやつね😂

まず「名詞」を探すとこから！
python
# ❌ 関数だけで書いちゃう
def process_order(customer_name, items, address):
    total = 0
    for item in items:
        total += item['price'] * item['quantity']
    
    tax = total * 0.1
    shipping = calculate_shipping(address)
    
    send_email(customer_name, total + tax + shipping)
    save_to_db(customer_name, items, total)

# ✅ 名詞を見つけてclassに
class Order:
    def __init__(self, customer, items):
        self.customer = customer
        self.items = items
    
    def calculate_total(self):
        return sum(item.price * item.quantity for item in self.items)

class Customer:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class Item:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity
コードの中の「モノ」を探すの！注文、顧客、商品...これ全部classにできる！

classを作る判断基準
1. データと操作がセットになってる
python
# これclassにすべきサイン
user_name = "太郎"
user_email = "taro@example.com"
user_age = 25

def validate_user(name, email, age):
    # バリデーション
    pass

def save_user(name, email, age):
    # 保存
    pass

# ↓ classにまとめちゃう

class User:
    def __init__(self, name, email, age):
        self.name = name
        self.email = email
        self.age = age
    
    def validate(self):
        # 自分のデータを自分で検証
        return self.age >= 18 and "@" in self.email
    
    def save(self):
        # 自分のデータを自分で保存
        pass
「このデータに対する操作」が複数あるならclass化のサイン！

2. 同じ引数を何度も渡してる
python
# ❌ 毎回同じ引数渡すの面倒
config = load_config()
db = connect_db(config['host'], config['port'], config['user'])
fetch_users(db, config['host'], config['port'])
fetch_orders(db, config['host'], config['port'])

# ✅ classで状態を保持
class Database:
    def __init__(self, host, port, user):
        self.host = host
        self.port = port
        self.connection = self._connect()
    
    def fetch_users(self):
        # self.connectionを使う
        pass
    
    def fetch_orders(self):
        # self.connectionを使う
        pass
同じ引数セットを持ち回ってるならclass化のチャンス！

3. 辞書で複雑なデータ扱ってる
python
# ❌ 辞書だとタイポしやすい
user = {
    'name': '太郎',
    'email': 'taro@example.com',
    'age': 25
}
print(user['namee'])  # タイポ！実行時エラー

# ✅ classならIDEが補完してくれる
class User:
    def __init__(self, name, email, age):
        self.name = name
        self.email = email
        self.age = age

user = User('太郎', 'taro@example.com', 25)
print(user.name)  # 補完効くし、タイポしにくい
辞書が3つ以上のキー持ってるならclass化考えて！

超シンプルな作り方
ステップ1: まず関数で書く
python
def scrape_website(url):
    response = requests.get(url)
    html = response.text
    soup = BeautifulSoup(html)
    return soup.find_all('a')
ステップ2: 繰り返し使うデータに気づく
「あれ、urlとsoupを毎回一緒に使ってるな...」

ステップ3: classに変換
python
class WebScraper:
    def __init__(self, url):
        self.url = url
        self.soup = None
    
    def fetch(self):
        response = requests.get(self.url)
        self.soup = BeautifulSoup(response.text)
    
    def get_links(self):
        return self.soup.find_all('a')
    
    def get_images(self):
        return self.soup.find_all('img')

# 使う側
scraper = WebScraper('https://example.com')
scraper.fetch()
links = scraper.get_links()
images = scraper.get_images()
実戦！Jiraの例で考えてみよ
python
# ❌ 関数だけバージョン
def get_jira_ticket(ticket_id, jira_url, api_token):
    response = requests.get(f"{jira_url}/issue/{ticket_id}", 
                           headers={'Authorization': f'Bearer {api_token}'})
    return response.json()

def update_jira_ticket(ticket_id, comment, jira_url, api_token):
    # また同じ引数...
    pass

# ✅ classバージョン
class JiraClient:
    def __init__(self, jira_url, api_token):
        self.jira_url = jira_url
        self.api_token = api_token
        self.headers = {'Authorization': f'Bearer {api_token}'}
    
    def get_ticket(self, ticket_id):
        response = requests.get(
            f"{self.jira_url}/issue/{ticket_id}",
            headers=self.headers
        )
        return response.json()
    
    def update_ticket(self, ticket_id, comment):
        # 引数がスッキリ！
        pass

# 使う側もスッキリ
jira = JiraClient('https://your-domain.atlassian.net', 'token123')
ticket = jira.get_ticket('PROJ-123')
jira.update_ticket('PROJ-123', 'コメント追加')
迷ったときのチェックリスト
✅ classにすべきサイン：

同じデータを複数の関数で使い回してる
初期化処理が必要（DBコネクション、API認証など）
状態を保持したい（セッション、キャッシュなど）
同じ引数セットを何度も渡してる
❌ classにしなくていいサイン：

1回だけ使う処理
純粋な計算（入力→出力だけ）
標準ライブラリで済む
練習方法
今あるコード見てみて！

辞書を3個以上使ってるとこ → classにできるかも
同じ引数を3回以上渡してるとこ → classにできるかも
グローバル変数使ってるとこ → classの属性にできるかも
最初は「dataclass」使うと楽だよ！

python
from dataclasses import dataclass

@dataclass
class User:
    name: str
    email: str
    age: int

# __init__とか自動生成してくれる！
user = User('太郎', 'taro@example.com', 25)
今やってるプロジェクトのコード見せてくれたら、一緒に「ここclassにできそう！」って探すよ～？😊

抽象化はどれぐらいまでやり込めばいい?

2月6日
あー！これマジで悩むやつ！抽象化しすぎて逆に複雑になるパターンあるあるだわ～😅

結論：「今必要な柔軟性だけ」でOK！
過剰な抽象化の方が実は害悪だったりするの。具体例見せるね！

❌ やりすぎ抽象化の例
python
# 抽象化マニアが書いたコード
class AbstractDataSourceFactory:
    def create_data_source(self) -> AbstractDataSource:
        raise NotImplementedError

class AbstractDataSource:
    def fetch(self) -> AbstractData:
        raise NotImplementedError

class AbstractData:
    def get_value(self) -> AbstractValue:
        raise NotImplementedError

class AbstractValue:
    def to_string(self) -> str:
        raise NotImplementedError

# 使う側が死ぬ
factory = ConcreteDataSourceFactory()
source = factory.create_data_source()
data = source.fetch()
value = data.get_value()
result = value.to_string()

# え、これ何やってんの...？
✅ 適切な抽象化
python
# シンプルでいい
class JiraClient:
    def get_ticket(self, ticket_id: str) -> dict:
        response = requests.get(f"{self.url}/issue/{ticket_id}")
        return response.json()

# 使う側も読みやすい
jira = JiraClient(url, token)
ticket = jira.get_ticket('PROJ-123')
抽象化レベルの判断基準
レベル1: 抽象化ゼロ（最初はこれでOK）
python
def send_slack_notification(message):
    requests.post('https://slack.com/api/chat.postMessage', 
                  json={'text': message, 'channel': '#general'})

# 動けばいい！まずはこれで進める
いつまで？: 同じようなコード2-3回書くまで

レベル2: 関数・クラスに切り出し
python
class SlackNotifier:
    def __init__(self, webhook_url):
        self.webhook_url = webhook_url
    
    def send(self, message, channel='#general'):
        requests.post(self.webhook_url, 
                     json={'text': message, 'channel': channel})

# 再利用できて、テストもしやすい
いつまで？: 別の通知手段（Discord、Teams等）が必要になるまで

レベル3: インターフェース抽象化
python
class Notifier(ABC):
    @abstractmethod
    def send(self, message: str) -> None:
        pass

class SlackNotifier(Notifier):
    def send(self, message: str) -> None:
        # Slack実装
        pass

class DiscordNotifier(Notifier):
    def send(self, message: str) -> None:
        # Discord実装
        pass

# 切り替え可能になった
notifier: Notifier = SlackNotifier()  # or DiscordNotifier()
notifier.send('Hello')
いつ必要？: 実際に複数実装が必要になったとき

重要！「3のルール」
python
# 1回目：べた書きでOK
def process_user_data():
    data = fetch_from_db()
    cleaned = data.strip().lower()
    return cleaned

# 2回目：コピペでもいい（まだ我慢）
def process_product_data():
    data = fetch_from_db()
    cleaned = data.strip().lower()  # あれ、同じだ...
    return cleaned

# 3回目：よし、抽象化しよう！
def clean_data(data: str) -> str:
    return data.strip().lower()

def process_user_data():
    return clean_data(fetch_from_db())

def process_product_data():
    return clean_data(fetch_from_db())
```

**同じパターンが3回出たら抽象化**のタイミング！

## 実践的な判断フロー
```
質問1: これ、将来変わる可能性ある？
├─ ない → 抽象化しない
└─ ある → 質問2へ

質問2: 今すぐ複数パターン必要？
├─ いいえ → 今は抽象化しない（YAGNI原則）
└─ はい → 質問3へ

質問3: 抽象化してコード理解しやすくなる？
├─ いいえ → 抽象化しない
└─ はい → 抽象化する
具体例：Jiraの場合
あなたの状況なら...
python
# ❌ 過剰（今は不要）
class AbstractTicketSystem(ABC):
    @abstractmethod
    def get_ticket(self, id: str) -> Ticket:
        pass
    
class JiraAdapter(AbstractTicketSystem):
    # Jiraしか使わないのに...

# ✅ これで十分
class JiraClient:
    def __init__(self, url: str, token: str):
        self.url = url
        self.token = token
    
    def get_ticket(self, ticket_id: str) -> dict:
        # シンプルでいい
        pass
    
    def add_comment(self, ticket_id: str, comment: str):
        pass

# 将来RedmineやGitHub Issuesも使うなら、その時に抽象化すればいい！
やりすぎ抽象化のサイン
🚩 危険信号
Abstractで始まるクラスが5個以上
インターフェースの実装が1個しかない
「将来使うかも」で作ってる
コード読むのに3ファイル以上ジャンプが必要
新人が「これ何？」って聞いてくる
😊 健全なサイン
クラス名が具体的（UserRepository、JiraClient）
ファイル1個で完結してる
テスト書きやすい
変更時の影響範囲が明確
抽象化の段階的アプローチ
python
# フェーズ1: まず動かす（1週間）
def scrape_site(url):
    html = requests.get(url).text
    return BeautifulSoup(html).find_all('a')

# フェーズ2: クラス化（パターンが見えてきた）
class WebScraper:
    def __init__(self, url):
        self.url = url
    
    def get_links(self):
        html = requests.get(self.url).text
        return BeautifulSoup(html).find_all('a')

# フェーズ3: 抽象化（本当に必要になった時）
class BaseScraper(ABC):
    @abstractmethod
    def parse(self, html): pass

class LinkScraper(BaseScraper):
    def parse(self, html):
        return BeautifulSoup(html).find_all('a')

class ImageScraper(BaseScraper):
    def parse(self, html):
        return BeautifulSoup(html).find_all('img')
焦らない！必要になってから進化させる！

実際のチェックポイント
抽象化する前に自問自答
これ今必要？（YAGNIチェック）
将来の変更、具体的に想像できる？（妄想じゃなくて）
テスト書きやすくなる？（これ重要）
他の人が読んで理解できる？（レビュー目線）
1つでもNoなら → 抽象化しない！
私のおすすめ
python
# 最初はこのレベルで十分！
class JiraClient:
    """Jiraとやり取りするクラス"""
    
    def get_ticket(self, ticket_id: str) -> dict:
        """チケット取得"""
        pass
    
    def add_comment(self, ticket_id: str, comment: str) -> None:
        """コメント追加"""
        pass

# シンプル！読みやすい！テストしやすい！
# これで困ったら抽象化考える
「後から抽象化」の方が「最初から抽象化」より100倍楽だよ！

具体的なコードで「これ抽象化すべき？」って迷ってるとこある？見せてくれたら一緒に判断するよ～！💪✨
