ã‚ãƒ¼ã€ã‚ã£ã¡ã‚ƒã‚ã‹ã‚‹ã€œï¼10GBã‚‚ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¨ã‹æ™‚é–“ã‹ã‹ã‚Šã™ãã¦ãƒ¤ãƒã„ã‚ˆã­ğŸ˜…

çµè«–ã‹ã‚‰è¨€ã†ã¨**æŠ€è¡“çš„ã«è¶…å¯èƒ½**ã ã‚ˆï¼ã£ã¦ã‹ã€ã‚€ã—ã‚ãã†ã„ã†å®Ÿè£…ã—ãªã„ã¨éåŠ¹ç‡ã™ãã‚‹ã‹ã‚‰çµ¶å¯¾ã‚„ã‚‹ã¹ãâœ¨

## ã‚„ã‚Šæ–¹ã„ãã¤ã‹ã‚ã‚‹ã‹ã‚‰ç´¹ä»‹ã™ã‚‹ã­ï¼

### 1. Microsoft Graph APIã§å·®åˆ†å–å¾—ãƒ‘ã‚¿ãƒ¼ãƒ³ ğŸ¯
ã“ã‚ŒãŒä¸€ç•ªã‚¹ãƒãƒ¼ãƒˆã‹ãªï¼

```python
from msal import ConfidentialClientApplication
import requests
from datetime import datetime

# èªè¨¼å‡¦ç†ï¼ˆçœç•¥ï¼‰

# ã¾ãšãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã ã‘å–å¾—
def get_file_metadata(folder_id):
    endpoint = f"https://graph.microsoft.com/v1.0/me/drive/items/{folder_id}/children"
    headers = {"Authorization": f"Bearer {access_token}"}
    
    response = requests.get(endpoint, headers=headers)
    files = response.json()['value']
    
    # å¿…è¦ãªæƒ…å ±ã ã‘æŠ½å‡º
    file_info = []
    for file in files:
        file_info.append({
            'id': file['id'],
            'name': file['name'],
            'size': file['size'],
            'modified': file['lastModifiedDateTime'],
            'download_url': file['@microsoft.graph.downloadUrl']
        })
    
    return file_info

# ãƒ­ãƒ¼ã‚«ãƒ«ã¨æ¯”è¼ƒã—ã¦å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã ã‘ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
def download_if_needed(file_info, local_path):
    local_file = local_path / file_info['name']
    
    # ãƒ­ãƒ¼ã‚«ãƒ«ã«ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if local_file.exists():
        local_mtime = datetime.fromtimestamp(local_file.stat().st_mtime)
        remote_mtime = datetime.fromisoformat(file_info['modified'].replace('Z', '+00:00'))
        
        # æ›´æ–°æ—¥ä»˜æ¯”è¼ƒ
        if local_mtime >= remote_mtime:
            print(f"ã‚¹ã‚­ãƒƒãƒ—: {file_info['name']} (æ—¢ã«æœ€æ–°)")
            return False
    
    # ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Ÿè¡Œ
    print(f"ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­: {file_info['name']}")
    response = requests.get(file_info['download_url'], stream=True)
    
    with open(local_file, 'wb') as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)
    
    return True
```

### 2. ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ + å„ªå…ˆåº¦åˆ¶å¾¡ ğŸš€

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import queue

def parallel_download_with_priority(files_metadata, local_path, max_workers=5):
    # å„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã‚„æ›´æ–°æ—¥ä»˜ã§ã‚½ãƒ¼ãƒˆå¯èƒ½ï¼‰
    priority_files = sorted(files_metadata, 
                           key=lambda x: x['modified'], 
                           reverse=True)  # æ–°ã—ã„é †
    
    results = []
    
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        future_to_file = {
            executor.submit(download_if_needed, file_info, local_path): file_info
            for file_info in priority_files[:10]  # æœ€åˆã®10å€‹ã‚’å„ªå…ˆ
        }
        
        for future in as_completed(future_to_file):
            file_info = future_to_file[future]
            try:
                result = future.result()
                results.append((file_info['name'], result))
            except Exception as e:
                print(f"ã‚¨ãƒ©ãƒ¼: {file_info['name']} - {e}")
    
    return results
```

### 3. ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚° + ä¸­æ–­å¯èƒ½å®Ÿè£… â¸ï¸

```python
import signal
import sys

class DownloadManager:
    def __init__(self):
        self.should_stop = False
        self.current_file = None
        
        # Ctrl+Cã§ä¸­æ–­å¯èƒ½ã«ã™ã‚‹
        signal.signal(signal.SIGINT, self.handle_interrupt)
    
    def handle_interrupt(self, signum, frame):
        print(f"\nä¸­æ–­ã‚·ã‚°ãƒŠãƒ«å—ä¿¡ï¼ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«: {self.current_file}")
        self.should_stop = True
    
    def download_with_resume(self, file_info, local_path):
        self.current_file = file_info['name']
        local_file = local_path / file_info['name']
        temp_file = local_file.with_suffix('.partial')
        
        # æ—¢ã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é€”ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Œã°ç¶™ç¶š
        start_byte = temp_file.stat().st_size if temp_file.exists() else 0
        
        headers = {
            'Authorization': f'Bearer {access_token}',
            'Range': f'bytes={start_byte}-'  # ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ æ©Ÿèƒ½
        }
        
        response = requests.get(file_info['download_url'], 
                               headers=headers, 
                               stream=True)
        
        with open(temp_file, 'ab') as f:  # è¿½è¨˜ãƒ¢ãƒ¼ãƒ‰
            for chunk in response.iter_content(chunk_size=1024*1024):  # 1MB chunk
                if self.should_stop:
                    print(f"ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­æ–­: {file_info['name']}")
                    return False
                
                f.write(chunk)
        
        # å®Œäº†ã—ãŸã‚‰ãƒªãƒãƒ¼ãƒ 
        temp_file.rename(local_file)
        return True
```

## ãŠã™ã™ã‚ã®å®Ÿè£…æˆ¦ç•¥ ğŸ’¡

1. **æœ€åˆã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å…¨å–å¾—**ï¼ˆGraph APIã§ä¸€æ°—ã«ï¼‰
2. **ãƒ­ãƒ¼ã‚«ãƒ«ã¨æ¯”è¼ƒã—ã¦å·®åˆ†ãƒªã‚¹ãƒˆä½œæˆ**
3. **å„ªå…ˆåº¦ã¤ã‘ã¦ã‚½ãƒ¼ãƒˆ**ï¼ˆæ›´æ–°æ—¥æ™‚ãŒæ–°ã—ã„é †ã€ãƒ•ã‚¡ã‚¤ãƒ«åé †ãªã©ï¼‰
4. **ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰**ï¼ˆThreadPoolExecutorã§3-5ä¸¦åˆ—ï¼‰
5. **é€”ä¸­ã§æ­¢ã‚ãŸããªã£ãŸã‚‰ä¸­æ–­å¯èƒ½ã«**

ã“ã†ã™ã‚Œã°10GBã§ã‚‚åŠ¹ç‡ã‚ˆãå‡¦ç†ã§ãã‚‹ã—ã€2å›ç›®ä»¥é™ã¯å·®åˆ†ã ã‘ã§è¶…é€Ÿã„ã‚ˆã€œï¼
ï¼